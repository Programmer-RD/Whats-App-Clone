"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Client = exports.setAccessToken = exports.setRefreshToken = void 0;
const node_fetch_1 = require("node-fetch");
const stream_1 = require("stream");
const error_1 = require("./error");
const logger = require("./logger");
const responseToError = require("./responseToError");
const CLI_VERSION = require("../package.json").version;
let accessToken = "";
let refreshToken = "";
function setRefreshToken(token = "") {
    refreshToken = token;
}
exports.setRefreshToken = setRefreshToken;
function setAccessToken(token = "") {
    accessToken = token;
}
exports.setAccessToken = setAccessToken;
class Client {
    constructor(opts) {
        this.opts = opts;
        if (this.opts.auth === undefined) {
            this.opts.auth = true;
        }
        if (this.opts.urlPrefix.endsWith("/")) {
            this.opts.urlPrefix = this.opts.urlPrefix.substring(0, this.opts.urlPrefix.length - 1);
        }
    }
    get(path, options = {}) {
        const reqOptions = Object.assign(options, {
            method: "GET",
            path,
        });
        return this.request(reqOptions);
    }
    post(path, json, options = {}) {
        const reqOptions = Object.assign(options, {
            method: "POST",
            path,
            json,
        });
        return this.request(reqOptions);
    }
    patch(path, json, options = {}) {
        const reqOptions = Object.assign(options, {
            method: "PATCH",
            path,
            json,
        });
        return this.request(reqOptions);
    }
    delete(path, options = {}) {
        const reqOptions = Object.assign(options, {
            method: "DELETE",
            path,
        });
        return this.request(reqOptions);
    }
    request(reqOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!reqOptions.responseType) {
                reqOptions.responseType = "json";
            }
            if (reqOptions.responseType === "stream" && !reqOptions.resolveOnHTTPError) {
                throw new error_1.FirebaseError("apiv2 will not handle HTTP errors while streaming and you must set `resolveOnHTTPError` and check for res.status >= 400 on your own", { exit: 2 });
            }
            reqOptions = this.addRequestHeaders(reqOptions);
            if (this.opts.auth) {
                reqOptions = yield this.addAuthHeader(reqOptions);
            }
            try {
                return this.doRequest(reqOptions);
            }
            catch (err) {
                if (err instanceof error_1.FirebaseError) {
                    throw err;
                }
                throw new error_1.FirebaseError(`Failed to make request: ${err}`, { original: err });
            }
        });
    }
    addRequestHeaders(reqOptions) {
        if (!reqOptions.headers) {
            reqOptions.headers = {};
        }
        reqOptions.headers["Connection"] = "keep-alive";
        reqOptions.headers["User-Agent"] = `FirebaseCLI/${CLI_VERSION}`;
        reqOptions.headers["X-Client-Version"] = `FirebaseCLI/${CLI_VERSION}`;
        if (reqOptions.responseType === "json") {
            reqOptions.headers["Content-Type"] = "application/json";
        }
        return reqOptions;
    }
    addAuthHeader(reqOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!reqOptions.headers) {
                reqOptions.headers = {};
            }
            const token = yield this.getAccessToken();
            reqOptions.headers["Authorization"] = `Bearer ${token}`;
            return reqOptions;
        });
    }
    getAccessToken() {
        return __awaiter(this, void 0, void 0, function* () {
            if (accessToken) {
                return accessToken;
            }
            const data = yield require("./auth").getAccessToken(refreshToken, []);
            return data.access_token;
        });
    }
    requestURL(options) {
        const versionPath = this.opts.apiVersion ? `/${this.opts.apiVersion}` : "";
        return `${this.opts.urlPrefix}${versionPath}${options.path}`;
    }
    doRequest(options) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!options.path.startsWith("/")) {
                options.path = "/" + options.path;
            }
            let fetchURL = this.requestURL(options);
            if (options.queryParams) {
                const sp = [];
                for (const key of Object.keys(options.queryParams)) {
                    const value = options.queryParams[key];
                    sp.push(`${key}=${encodeURIComponent(value)}`);
                }
                if (sp.length) {
                    fetchURL += "?" + sp.join("&");
                }
            }
            const fetchOptions = {
                headers: options.headers,
                method: options.method,
            };
            if (options.json) {
                fetchOptions.body = JSON.stringify(options.json);
            }
            this.logRequest(options);
            let res;
            try {
                res = yield node_fetch_1.default(fetchURL, fetchOptions);
            }
            catch (err) {
                throw new error_1.FirebaseError(`Failed to make request to ${fetchURL}`, { original: err });
            }
            let body;
            if (options.responseType === "json") {
                body = yield res.json();
            }
            else if (options.responseType === "stream") {
                body = res.body;
            }
            else {
                body = (yield res.text());
            }
            this.logResponse(res, body, options);
            if (res.status >= 400) {
                if (!options.resolveOnHTTPError) {
                    throw responseToError({ statusCode: res.status }, body);
                }
            }
            return {
                status: res.status,
                response: res,
                body,
            };
        });
    }
    logRequest(options) {
        var _a, _b;
        let queryParamsLog = "[none]";
        if (options.queryParams) {
            queryParamsLog = "[omitted]";
            if (!((_a = options.skipLog) === null || _a === void 0 ? void 0 : _a.queryParams)) {
                queryParamsLog = JSON.stringify(options.queryParams);
            }
        }
        const logURL = this.requestURL(options);
        logger.debug(`>>> [apiv2][query] ${options.method} ${logURL} ${queryParamsLog}`);
        if (options.json) {
            let logBody = "[omitted]";
            if (!((_b = options.skipLog) === null || _b === void 0 ? void 0 : _b.body)) {
                logBody = JSON.stringify(options.json);
            }
            logger.debug(`>>> [apiv2][body] ${options.method} ${logURL} ${logBody}`);
        }
    }
    logResponse(res, body, options) {
        var _a;
        const logURL = this.requestURL(options);
        logger.debug(`<<< [apiv2][status] ${options.method} ${logURL} ${res.status}`);
        let logBody = "[omitted]";
        if (!((_a = options.skipLog) === null || _a === void 0 ? void 0 : _a.resBody)) {
            if (body instanceof stream_1.Readable) {
                logBody = "[stream]";
            }
            else {
                try {
                    logBody = JSON.stringify(body);
                }
                catch (_) {
                    logBody = `${body}`;
                }
            }
        }
        logger.debug(`<<< [apiv2][body] ${options.method} ${logURL} ${logBody}`);
    }
}
exports.Client = Client;
